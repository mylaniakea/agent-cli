"""Git hooks for automatic context updates."""

import os
import subprocess
from pathlib import Path
from typing import List, Optional


class GitHooksManager:
    """Manages git hooks for automatic context updates."""

    HOOK_SCRIPT_TEMPLATE = '''#!/bin/bash
# Agent CLI - Automatic context update hook
# Generated by agent-cli on {timestamp}

# Run agent CLI context update
if command -v agent-cli &> /dev/null; then
    agent-cli context update --hook {hook_name}
elif [ -f "./agent" ]; then
    ./agent context update --hook {hook_name}
else
    echo "Warning: agent-cli not found, skipping context update"
fi
'''

    def __init__(self, repo_path: Optional[Path] = None):
        """Initialize git hooks manager.

        Args:
            repo_path: Path to git repository (default: current directory)
        """
        self.repo_path = Path(repo_path) if repo_path else Path.cwd()
        self.hooks_dir = self.repo_path / ".git" / "hooks"

    def is_git_repo(self) -> bool:
        """Check if current directory is a git repository."""
        return (self.repo_path / ".git").exists()

    def install_hooks(self, hooks: Optional[List[str]] = None) -> dict:
        """Install git hooks for context updates.

        Args:
            hooks: List of hook names to install. Defaults to ['post-commit', 'post-merge']

        Returns:
            Dictionary with installation results
        """
        if not self.is_git_repo():
            return {"success": False, "error": "Not a git repository"}

        if hooks is None:
            hooks = ["post-commit", "post-merge"]

        results = {}
        installed = []
        skipped = []
        errors = []

        for hook_name in hooks:
            hook_path = self.hooks_dir / hook_name

            # Check if hook already exists
            if hook_path.exists():
                # Check if it's our hook
                content = hook_path.read_text()
                if "Agent CLI" in content:
                    skipped.append(hook_name)
                    continue
                else:
                    # Backup existing hook
                    backup_path = self.hooks_dir / f"{hook_name}.backup"
                    try:
                        hook_path.rename(backup_path)
                        results[f"{hook_name}_backup"] = str(backup_path)
                    except Exception as e:
                        errors.append(f"{hook_name}: Failed to backup - {e}")
                        continue

            # Create hook script
            try:
                from datetime import datetime
                script = self.HOOK_SCRIPT_TEMPLATE.format(
                    timestamp=datetime.now().isoformat(),
                    hook_name=hook_name
                )
                hook_path.write_text(script)
                hook_path.chmod(0o755)  # Make executable
                installed.append(hook_name)
            except Exception as e:
                errors.append(f"{hook_name}: {e}")

        return {
            "success": len(errors) == 0,
            "installed": installed,
            "skipped": skipped,
            "errors": errors
        }

    def uninstall_hooks(self, hooks: Optional[List[str]] = None) -> dict:
        """Uninstall git hooks.

        Args:
            hooks: List of hook names to uninstall. Defaults to all Agent CLI hooks

        Returns:
            Dictionary with uninstallation results
        """
        if not self.is_git_repo():
            return {"success": False, "error": "Not a git repository"}

        if hooks is None:
            # Find all Agent CLI hooks
            hooks = []
            for hook_file in self.hooks_dir.glob("*"):
                if hook_file.is_file() and not hook_file.name.endswith(".backup"):
                    try:
                        content = hook_file.read_text()
                        if "Agent CLI" in content:
                            hooks.append(hook_file.name)
                    except:
                        pass

        removed = []
        errors = []

        for hook_name in hooks:
            hook_path = self.hooks_dir / hook_name

            if not hook_path.exists():
                continue

            try:
                # Check if it's our hook before removing
                content = hook_path.read_text()
                if "Agent CLI" in content:
                    hook_path.unlink()
                    removed.append(hook_name)

                    # Restore backup if exists
                    backup_path = self.hooks_dir / f"{hook_name}.backup"
                    if backup_path.exists():
                        backup_path.rename(hook_path)
            except Exception as e:
                errors.append(f"{hook_name}: {e}")

        return {
            "success": len(errors) == 0,
            "removed": removed,
            "errors": errors
        }

    def list_hooks(self) -> dict:
        """List installed git hooks.

        Returns:
            Dictionary with hook information
        """
        if not self.is_git_repo():
            return {"success": False, "error": "Not a git repository"}

        agent_hooks = []
        other_hooks = []

        if self.hooks_dir.exists():
            for hook_file in self.hooks_dir.glob("*"):
                if hook_file.is_file() and not hook_file.name.endswith(".backup"):
                    try:
                        content = hook_file.read_text()
                        if "Agent CLI" in content:
                            agent_hooks.append(hook_file.name)
                        else:
                            other_hooks.append(hook_file.name)
                    except:
                        other_hooks.append(hook_file.name)

        return {
            "success": True,
            "agent_hooks": agent_hooks,
            "other_hooks": other_hooks
        }

    def get_recent_commits(self, count: int = 5) -> List[dict]:
        """Get recent commit information.

        Args:
            count: Number of commits to retrieve

        Returns:
            List of commit dictionaries
        """
        if not self.is_git_repo():
            return []

        try:
            result = subprocess.run(
                ["git", "log", f"-{count}", "--pretty=format:%H|%an|%ae|%ai|%s"],
                cwd=self.repo_path,
                capture_output=True,
                text=True
            )

            if result.returncode != 0:
                return []

            commits = []
            for line in result.stdout.strip().split("\n"):
                if not line:
                    continue
                parts = line.split("|", 4)
                if len(parts) == 5:
                    commits.append({
                        "hash": parts[0],
                        "author": parts[1],
                        "email": parts[2],
                        "date": parts[3],
                        "message": parts[4]
                    })

            return commits
        except Exception:
            return []

    def get_branch_name(self) -> Optional[str]:
        """Get current branch name.

        Returns:
            Branch name or None
        """
        if not self.is_git_repo():
            return None

        try:
            result = subprocess.run(
                ["git", "branch", "--show-current"],
                cwd=self.repo_path,
                capture_output=True,
                text=True
            )
            if result.returncode == 0:
                return result.stdout.strip()
        except Exception:
            pass

        return None

    def get_changed_files(self, commit_hash: Optional[str] = None) -> List[str]:
        """Get list of changed files.

        Args:
            commit_hash: Specific commit hash, or None for uncommitted changes

        Returns:
            List of file paths
        """
        if not self.is_git_repo():
            return []

        try:
            if commit_hash:
                # Files changed in specific commit
                result = subprocess.run(
                    ["git", "diff-tree", "--no-commit-id", "--name-only", "-r", commit_hash],
                    cwd=self.repo_path,
                    capture_output=True,
                    text=True
                )
            else:
                # Uncommitted changes
                result = subprocess.run(
                    ["git", "status", "--porcelain"],
                    cwd=self.repo_path,
                    capture_output=True,
                    text=True
                )

            if result.returncode != 0:
                return []

            files = []
            for line in result.stdout.strip().split("\n"):
                if not line:
                    continue
                if commit_hash:
                    files.append(line)
                else:
                    # Parse status format
                    if len(line) > 3:
                        files.append(line[3:])

            return files
        except Exception:
            return []

    def generate_context_summary(self) -> str:
        """Generate a summary of recent activity for context.

        Returns:
            Markdown summary of recent commits and changes
        """
        if not self.is_git_repo():
            return ""

        lines = []
        lines.append("# Recent Development Activity\n")

        # Current branch
        branch = self.get_branch_name()
        if branch:
            lines.append(f"**Current Branch:** {branch}\n")

        # Recent commits
        commits = self.get_recent_commits(5)
        if commits:
            lines.append("## Recent Commits\n")
            for commit in commits:
                short_hash = commit["hash"][:7]
                lines.append(f"- `{short_hash}` {commit['message']} ({commit['date'][:10]})")
            lines.append("")

        # Uncommitted changes
        changed_files = self.get_changed_files()
        if changed_files:
            lines.append("## Uncommitted Changes\n")
            for file in changed_files[:10]:  # Limit to 10 files
                lines.append(f"- {file}")
            if len(changed_files) > 10:
                lines.append(f"- ... and {len(changed_files) - 10} more files")
            lines.append("")

        return "\n".join(lines)


def install_git_hooks(repo_path: Optional[Path] = None, hooks: Optional[List[str]] = None) -> dict:
    """Convenience function to install git hooks.

    Args:
        repo_path: Path to git repository (default: current directory)
        hooks: List of hook names to install

    Returns:
        Dictionary with installation results
    """
    manager = GitHooksManager(repo_path)
    return manager.install_hooks(hooks)


def uninstall_git_hooks(repo_path: Optional[Path] = None, hooks: Optional[List[str]] = None) -> dict:
    """Convenience function to uninstall git hooks.

    Args:
        repo_path: Path to git repository (default: current directory)
        hooks: List of hook names to uninstall

    Returns:
        Dictionary with uninstallation results
    """
    manager = GitHooksManager(repo_path)
    return manager.uninstall_hooks(hooks)
